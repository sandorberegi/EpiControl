---
title: "Bayesian hyperparameter optimisation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hyperparameter_opt}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

```{r echo=FALSE, results='asis'}
cat("## Overview\n\n",
    "This vignette demonstrates the optimisation of algorithm hyperparameters using Bayesian optimisation \n\n")
```

Load the required libraries:

```{r setup}
library(EpiControl)
library(VGAM)
library(parallel)
library(pbapply)
library(zoo)  # For rolling sum operations
library(dplyr)
library(ggplot2)
library(rBayesianOptimization)
```

Set up the simulation and run it with our initial parameters:

```{r fix random seed}
set.seed(1)
```

Initialise the cluster for parallel computing:

```{r parallel-setup}
cores <- 2
cl <- makeCluster(cores)

clusterSetRNGStream(cl, iseed = 20250501)
```

```{r run-init-sim}
Epi_pars <- data.frame(
  Pathogen = c("COVID-19", "Ebola"),
  R0 = c(2.2, 2.5),
  gen_time = c(6.5, 15.0),
  gen_time_var = c(2.1, 2.1),
  CFR = c(0.0132, 0.5),
  mortality_mean = c(10.0, 10.0),
  mortality_var = c(1.1, 1.1)
)

Noise_pars <- data.frame(
  repd_mean = 10.5,  # Reporting delay mean
  del_disp = 5.0,    # Reporting delay variance
  ur_mean = 0.3,     # Under-reporting mean
  ur_beta_a = 50.0   # Beta distribution alpha for under-reporting
)

Action_space <- data.frame(
  NPI = c("No restrictions", "Lockdown"),
  R_coeff = c(1.0, 0.3),
  R_beta_a = c(0.0, 5.0),
  cost_of_NPI = c(0.0, 0.15)
)

C_target <- 5000
D_target <- 12
r_trans_len <- 7

sim_settings <- list(
  ndays = 40 * 7, #simulation length
  start_day = 1,
  N = 1e7, # population size
  I0 = 10, # initial infections
  C_target = C_target, #target cases
  C_target_pen = C_target*1.5, #overshoot penalty threshold
  R_target = 1.0,
  D_target = D_target, #one way to get peaks at 400 is to increase this to 15
  D_target_pen = 50, #max death
  alpha = 1.3/C_target, #~proportional gain (regulates error in cases) covid
  #alpha = 3.25/C_target #~proportional gain (regulates error in cases) ebola
  alpha_d = 0*1.3/D_target,
  ovp = 5.0, #overshoot penalty
  dovp = 0*10.0, #death overshoot penalty
  gamma = 0.95, #discounting factor
  n_ens = 20L, #MC assembly size for 4
  sim_ens = 10L, #assembly size for full simulation
  rf = 14L, #days 14
  R_est_wind = 5L, #rf-2 #window for R estimation
  susceptibles = 0,
  pred_days = 28L,
  r_trans_steep = 1.5,  # Growth rate
  r_trans_len = r_trans_len,  # Number of days for the transition
  t0 = r_trans_len  / 2, # Midpoint of the transition
  pathogen = 1,
  susceptibles = 0,
  delay = 1,
  ur = 1,
  r_dir = 2,
  LD_on = 14, #on threshold
  LD_off = 7, #off threshold
  v_max_rate = 0.8,
  vac_scale = 100,
  vac_start = 370,
  delta_scale = 40,
  delta_start = 550,
  delta_multiplier = 1.75,
  v_protection_delta = (58+85)/200,
  v_protection_alpha = 0.83
)

episettings <- list(
  sim_function = Epi_MPC_run_wd,
  reward_function = reward_fun_wd,
  R_estimator = R_epiestim,
  noise_par = Noise_pars,
  epi_par = Epi_pars,
  actions = Action_space,
  sim_settings = sim_settings,
  parallel = FALSE
)

column_names <- c("days", "sim_id", "I", "Lambda", "C", "Lambda_C", "S", "Deaths", "Re", "Rew", "Rest", "R0est", "policy", "R_coeff")
episim_data <- data.frame(matrix(0, nrow = (sim_settings$ndays), ncol = length(column_names)))
colnames(episim_data) <- column_names

episim_data$policy <- rep(1, sim_settings$ndays)
episim_data$days <- 1:(sim_settings$ndays)
episim_data[1, ] <- c(1, 1, sim_settings$I0, sim_settings$I0, Noise_pars$ur_mean * sim_settings$I0, Noise_pars$ur_mean * sim_settings$I0, sim_settings$N - sim_settings$I0, 0, Epi_pars[1, "R0"], Epi_pars[1, "R0"], 1, 1, 1, 1)

episim_data_ens <- replicate(sim_settings$sim_ens, episim_data, simplify = FALSE)

for (ii in 1:sim_settings$sim_ens) {
  episim_data_ens[[ii]]$sim_id <- rep(ii, sim_settings$ndays)
}


# Ensure actions$cost_of_NPI is numeric
Action_space$cost_of_NPI <- as.numeric(as.character(Action_space$cost_of_NPI))

# Verify numeric parameters in sim_settings
numeric_params <- c("alpha", "alpha_d", "ovp", "dovp", "C_target", "C_target_pen", "D_target", "D_target_pen", "pred_days", "sim_ens", "ndays", "N")
sim_settings[numeric_params] <- lapply(sim_settings[numeric_params], as.numeric)

# Don't forget to stop the cluster at the end

# Export required functions and objects to cluster
clusterExport(cl, ls())
clusterExport(cl, c("reward_fun_wd", "Epi_pred_wd", "Epi_MPC_run_wd", "episim_data_ens", "episettings", "Action_space", "Epi_pars", "Noise_pars", "R_estim"))

parallel::clusterEvalQ(cl, {
  library(pbapply)
  library(VGAM)
})

# Add the cluster object to your settings
episettings$parallel <- TRUE
episettings$cl <- cl

# Run the epicontrol function
results <- epicontrol(episim_data_ens, episettings)

```

### Defining our objective function

We want to minimise the combined costs of being off target and implementation of lockdowns. We want to optimise the projection horizon and discount factor when calculating costs at decision points.

```{r set-objective}

a<- 1.3/5000

objective <- function(horizon, discount) {

  sim_settings$pred_days <- horizon
  sim_settings$gamma <- discount

  episettings <- list(
    sim_function = Epi_MPC_run_wd,
    reward_function = reward_fun_wd,
    R_estimator = R_estim,
    noise_par = Noise_pars,
    epi_par = Epi_pars,
    actions = Action_space,
    sim_settings = sim_settings,
    parallel = FALSE
  )

  results <- epicontrol(episim_data_ens, episettings)

  rewards <- numeric(length(results))
  for (i in seq_along(results)) {
    res <- results[[i]]
    cases_v <- res$C
    interventions <- res$policy

    # single bracket: keeps length matching 'interventions'
    interv_costs <- Action_space$cost_of_NPI[interventions]

    case_err <- abs(cases_v - sim_settings$C_target)

    rewards[i] <- sum(-a * case_err - interv_costs)
  }

  mean_reward <- mean(rewards, na.rm = TRUE)
  list(Score = mean_reward,
       Pred = 0)
}
```

Let's do the optimisation:

```{r bayesopt}
OPT_Res <- BayesianOptimization(objective,
                                bounds = list(horizon = c(14L, 35L),
                                              discount = c(0.7, 0.99)),
                                init_points = 5, n_iter = 30,
                                acq = "ucb", kappa = 2.576, eps = 0.0,
                                verbose = TRUE)
```
